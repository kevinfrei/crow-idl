import * as prettier from 'prettier';
import {
  isAnonymousType,
  isArrayType,
  isBoolType,
  isCharType,
  isDoubleType,
  isFastMapType,
  isFastSetType,
  isFloatType,
  isI16Type,
  isI32Type,
  isI64Type,
  isI8Type,
  isMapType,
  isOptionalType,
  isRefType,
  isSetType,
  isStringType,
  isTupleType,
  isU16Type,
  isU32Type,
  isU64Type,
  isU8Type,
} from '../IDL';
import type {
  Emitter,
  Enum,
  IdlGenerator,
  NEnum,
  ObjType,
  SEnum,
  SubType,
  Types,
} from '../types';
import { MakeGenerator } from './api';

const typeMap: Map<string, Types> = new Map();

function SingleQuoteSafe(str: string): string {
  // Escape single quotes in the string for TypeScript
  return str.replace(/'/g, "\\'");
}

let sourceFileName = 'unknown.ts';
// let outputFileName = 'unknown.ts';

function setInputFilename(fileName: string): void {
  typeMap.clear();
  sourceFileName = fileName;
}

function setOutputFilename(): void {
  typeMap.clear();
}
/* (fileName: string): void {
   outputFileName = fileName;
}
*/

type TypeCheckList =
  | 'U8'
  | 'U16'
  | 'U32'
  | 'U64'
  | 'I8'
  | 'I16'
  | 'I32'
  | 'I64'
  | 'Float'
  | 'Double'
  | 'Char'
  | 'Optional';

const checks: Record<TypeCheckList, boolean> = {
  U8: false,
  U16: false,
  U32: false,
  U64: false,
  I8: false,
  I16: false,
  I32: false,
  I64: false,
  Float: false,
  Double: false,
  Char: false,
  Optional: false,
};

function generateHeader(): string[] {
  return `// DO NOT EDIT THIS FILE DIRECTLY!!!
// This file is generated from ${sourceFileName}.
// If you need to change this file, edit ${sourceFileName} and
// regenerate it.
// DO NOT EDIT THIS FILE DIRECTLY!!!
 
// Generated by ${process.env.npm_package_name} v${process.env.npm_package_version}

import * as TC from '@freik/typechk';

// TODO: Only emit the type checks that are needed

${
  checks.U8
    ? `const chkIdlU8 = (v: unknown): v is number =>
  TC.isNumber(v) && v >= 0 && v <= 255 && Number.isInteger(v);\n`
    : ''
}
${
  checks.I8
    ? `const chkIdlI8 = (v: unknown): v is number =>
  TC.isNumber(v) && v >= -128 && v <= 127 && Number.isInteger(v);\n`
    : ''
}
${
  checks.U16
    ? `const chkIdlU16 = (v: unknown): v is number =>
  TC.isNumber(v) && v >= 0 && v <= 65535 && Number.isInteger(v);\n`
    : ''
}
${
  checks.I16
    ? `const chkIdlI16 = (v: unknown): v is number =>
  TC.isNumber(v) && v >= -32768 && v <= 32767 && Number.isInteger(v);\n`
    : ''
}
${
  checks.U32
    ? `const chkIdlU32 = (v: unknown): v is number =>
  TC.isNumber(v) && v >= 0 && v <= 4294967295 && Number.isInteger(v);\n`
    : ''
}
${
  checks.I32
    ? `const chkIdlI32 = (v: unknown): v is number =>
  TC.isNumber(v) &&
  v >= -2147483648 &&
  v <= 2147483647 &&
  Number.isInteger(v);\n`
    : ''
}
${
  checks.U64
    ? `function chkIdlU64(v: unknown): v is number {
  if (TC.isNumber(v)) {
   return Number.isInteger(v) && chkIdlU64(BigInt(v));
  }
  return TC.isBigInt(v) && BigInt.asUintN(64, v) === v;
}\n`
    : ''
}
${
  checks.I64
    ? `function chkIdlI64(v: unknown): v is number {
  if (TC.isNumber(v)) {
   return Number.isInteger(v) && chkIdlI64(BigInt(v));
  }
  return TC.isBigInt(v) && BigInt.asIntN(64, v) === v;
}\n`
    : ''
}
${
  checks.Float
    ? `function chkIdlFloat(v: unknown): v is number {
  return TC.isNumber(v) && !Number.isNaN(v) && Number.isFinite(Math.fround(v)) && (v === 0 || Math.fround(v) !== 0);
}\n`
    : ''
}
${
  checks.Double
    ? `function chkIdlDouble(v: unknown): v is number {
  return TC.isNumber(v) && !Number.isNaN(v) && Number.isFinite(v);
}\n`
    : ''
}
${
  checks.Char
    ? `function chkIdlChar(v: unknown): v is string {
  return TC.isString(v) && v.length === 1;
}\n`
    : ''
}
${
  checks.Optional
    ? `function chkOptional<T>(chk: TC.typecheck<T>): TC.typecheck<T | undefined> {
  return (v: unknown): v is T | undefined => v === undefined || chk(v);
}\n`
    : ''
}
`.split('\n');
}

function generateFooter(): string[] {
  return ['', '// End of generated code', ''];
}

function getTypeName(type: Types, optUndef?: boolean): string {
  if (
    isU8Type(type) ||
    isI8Type(type) ||
    isU16Type(type) ||
    isI16Type(type) ||
    isU32Type(type) ||
    isI32Type(type) ||
    isFloatType(type) ||
    isDoubleType(type)
  ) {
    return 'number';
  } else if (isU64Type(type) || isI64Type(type)) {
    return 'bigint';
  } else if (isStringType(type) || isCharType(type)) {
    return 'string';
  } else if (isBoolType(type)) {
    return 'boolean';
  } else if (isRefType(type)) {
    return type.r; // Reference type, just return the name
  } else if (isArrayType(type)) {
    return `${getTypeName(type.d, true)}[]`;
  } else if (isSetType(type) || isFastSetType(type)) {
    return `Set<${getTypeName(type.d, true)}>`;
  } else if (isMapType(type) || isFastMapType(type)) {
    return `Map<${getTypeName(type.k, true)}, ${getTypeName(type.v, true)}>`;
  } else if (isTupleType(type)) {
    return `[${type.l.map((t) => getTypeName(t, true)).join(', ')}]`;
  } else if (isOptionalType(type)) {
    return optUndef
      ? `(${getTypeName(type.d, false)} | undefined)`
      : getTypeName(type.d, false);
  }
  throw new Error(`Unsupported unnamed type: ${JSON.stringify(type)}`);
}

function getTypeCheckName(type: Types): string {
  if (isU8Type(type)) {
    checks.U8 = true;
    return 'chkIdlU8';
  } else if (isI8Type(type)) {
    checks.I8 = true;
    return 'chkIdlI8';
  } else if (isU16Type(type)) {
    checks.U16 = true;
    return 'chkIdlU16';
  } else if (isI16Type(type)) {
    checks.I16 = true;
    return 'chkIdlI16';
  } else if (isU32Type(type)) {
    checks.U32 = true;
    return 'chkIdlU32';
  } else if (isI32Type(type)) {
    checks.I32 = true;
    return 'chkIdlI32';
  } else if (isU64Type(type)) {
    checks.U64 = true;
    return 'chkIdlU64';
  } else if (isI64Type(type)) {
    checks.I64 = true;
    return 'chkIdlI64';
  } else if (isFloatType(type)) {
    checks.Float = true;
    return 'chkIdlFloat';
  } else if (isDoubleType(type)) {
    checks.Double = true;
    return 'chkIdlDouble';
  } else if (isStringType(type)) {
    return 'TC.isString';
  } else if (isCharType(type)) {
    checks.Char = true;
    return 'chkIdlChar';
  } else if (isBoolType(type)) {
    return 'TC.isBoolean';
  } else if (isRefType(type)) {
    return `chk${type.r}`;
  } else if (isArrayType(type)) {
    return `TC.chkArrayOf(${getTypeCheckName(type.d)})`;
  } else if (isSetType(type) || isFastSetType(type)) {
    return `TC.chkSetOf(${getTypeCheckName(type.d)})`;
  } else if (isMapType(type) || isFastMapType(type)) {
    return `TC.chkMapOf(${getTypeCheckName(type.k)}, ${getTypeCheckName(type.v)})`;
  } else if (isTupleType(type)) {
    return `TC.chkTupleOf(${type.l.map(getTypeCheckName).join(', ')})`;
  } else if (isOptionalType(type)) {
    checks.Optional = true;
    return `chkOptional(${getTypeCheckName(type.d)})`;
  }
  throw new Error(
    `Unsupported unnamed type for checking: ${JSON.stringify(type)}\n(Probably use a reference)`,
  );
}

function enumType(name: string, item: Enum): string[] {
  return `
export const ${name} = Object.freeze({
  ${item.v.map((val, idx) => `${val}: ${idx}`).join(',\n  ')}
});
export type ${name} = (typeof ${name})[keyof typeof ${name}];
export function chk${name}(val: unknown): val is ${name} {
  return TC.isNumber(val) && Object.values(${name}).includes(val as ${name});
}
`.split('\n');
}

function numEnumType(name: string, item: NEnum): string[] {
  return `
export const ${name} = Object.freeze({
${Object.entries(item.v)
  .map(([key, value]) => `  ${key}: ${value},`)
  .join('\n')}
});
export type ${name} = (typeof ${name})[keyof typeof ${name}];
export function chk${name}(val: unknown): val is ${name} {
  return TC.isNumber(val) && Object.values(${name}).includes(val as ${name});
}
`.split('\n');
}

function strEnumType(name: string, item: SEnum): string[] {
  return `
export const ${name} = Object.freeze({
${Object.entries(item.v)
  .map(([key, val]) => `  ${key}: '${SingleQuoteSafe(val)}',`)
  .join('\n')}
});
export type ${name} = (typeof ${name})[keyof typeof ${name}];
export function chk${name}(val: unknown): val is ${name} {
  return TC.isString(val) && Object.values(${name}).includes(val as ${name});
}
`.split('\n');
}

function objType(name: string, item: ObjType): string[] {
  const required = Object.entries(item.d)
    .filter(([, v]) => !isOptionalType(v))
    .map(([k, v]) => [k, v]);
  const optional = Object.entries(item.d)
    .filter(([, v]) => isOptionalType(v))
    .map(([k, v]) => [k, v]);
  if (required.length + optional.length !== Object.keys(item.d).length) {
    throw new Error(`Internal error: req/opt keys don't add up for ${name}`);
  }
  const res = ['', `export type ${name} = {`, ''];
  for (const [key, value] of Object.entries(item.d)) {
    const typeName = getTypeName(value);
    res.push(`  ${key}${isOptionalType(value) ? '?' : ''}: ${typeName};`);
  }
  res.push(`
}
export const chk${name}: TC.typecheck<${name}> = TC.chkObjectOfType({
${required
  .map(([key, value]) => `  ${key}: ${getTypeCheckName(value as Types)},`)
  .join('\n')}
    },
  {${optional
    .map(([key, value]) => `  ${key}: ${getTypeCheckName(value as Types)},`)
    .join('\n')}});
`);
  return res;
}

function subType(name: string, item: SubType): string[] {
  const res = ['', `export type ${name} = ${item.p} & {`];
  for (const [key, value] of Object.entries(item.d)) {
    const typeName = getTypeName(value);
    res.push(`  ${key}: ${typeName};`);
  }
  res.push(`
}
export const chk${name}: TC.typecheck<${name}> = TC.chkAllOf(
  chk${item.p},
  ${Object.entries(item.d)
    .map(
      ([key, value]) =>
        `  TC.chkFieldOf('${key}', ${getTypeCheckName(value)}),`,
    )
    .join('\n')}
);
`);
  return res;
}

function simpleType(name: string, item: Types): string[] {
  const res = [];
  res.push(`\nexport type ${name} = ${getTypeName(item, true)};`);
  if (isAnonymousType(item)) {
    res.push(`export const chk${name} = ${getTypeCheckName(item)};\n`);
  }
  return res;
}

async function postProcess(code: string[]): Promise<string[]> {
  // Perform any post-processing on the generated code here
  const joinedCode = code.join('\n');
  const formattedCode = await prettier.format(joinedCode, {
    printWidth: 80,
    trailingComma: 'none',
    singleQuote: true,
    proseWrap: 'always',
    tabWidth: 2,
    useTabs: false,
    bracketSameLine: true,
    arrowParens: 'always',
    parser: 'typescript',
    organizeImports: true,
    // "organizeImportsSkipDestructiveCodeActions": true,
    plugins: ['prettier-plugin-organize-imports'],
  });
  return formattedCode.split('\n');
}

export const TypescriptEmitter: Emitter = {
  generateHeader,
  generateFooter,
  setInputFilename,
  setOutputFilename,
  setAdditionalOptions: () => {}, //opts: Record<string, string>) => {},
  types: {
    simpleType,
    objType,
    subType,
    optType: simpleType,
    arrType: simpleType,
    setType: simpleType,
    fastSetType: simpleType,
    mapType: simpleType,
    fastMapType: simpleType,
    tupType: simpleType,
    enumType,
    strType: simpleType,
    numEnumType,
    strEnumType,
  },
  postProcess,
};

export function GetTypescriptGenerator(): IdlGenerator {
  // Returns the TypescriptEmitter instance
  return MakeGenerator(TypescriptEmitter);
}
