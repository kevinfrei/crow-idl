import {
  isAnonymousType,
  isArrayType,
  isBoolType,
  isCharType,
  isDoubleType,
  isFastMapType,
  isFastSetType,
  isFloatType,
  isI16Type,
  isI32Type,
  isI64Type,
  isI8Type,
  isMapType,
  isOptionalType,
  isRefType,
  isSetType,
  isStringType,
  isTupleType,
  isU16Type,
  isU32Type,
  isU64Type,
  isU8Type,
} from '../IDL';
import type {
  EmitItem,
  Emitter,
  Enum,
  FileGenerator,
  NEnum,
  ObjType,
  SEnum,
  SubType,
  Types,
} from '../types';
import { MakeGenerator } from './api';

function SingleQuoteSafe(str: string): string {
  // Escape single quotes in the string for TypeScript
  return str.replace(/'/g, "\\'");
}

async function header(writer: Bun.FileSink): Promise<void> {
  await writer.write(`// DO NOT EDIT THIS FILE DIRECTLY!!!
// This file is generated from www/Shared/Definitions.ts by running 'bun gen'
// If you need to change this file, edit www/Shared/Definitions.ts and run
// 'bun gen' again. Or, if you need to change the generation process, edit
// scripts/emitters/typescript.ts and run 'bun gen' again.
// DO NOT EDIT THIS FILE DIRECTLY!!!
 
import * as TypeChk from '@freik/typechk';

const chkIdlU8 = (v: unknown): v is number =>
  TypeChk.isNumber(v) && v >= 0 && v <= 255 && Number.isInteger(v);
const chkIdlI8 = (v: unknown): v is number =>
  TypeChk.isNumber(v) && v >= -256 && v <= 255 && Number.isInteger(v);
const chkIdlU16 = (v: unknown): v is number =>
  TypeChk.isNumber(v) && v >= 0 && v <= 65535 && Number.isInteger(v);
const chkIdlI16 = (v: unknown): v is number =>
  TypeChk.isNumber(v) && v >= -32768 && v <= 32767 && Number.isInteger(v);
const chkIdlU32 = (v: unknown): v is number =>
  TypeChk.isNumber(v) && v >= 0 && v <= 4294967295 && Number.isInteger(v);
const chkIdlI32 = (v: unknown): v is number =>
  TypeChk.isNumber(v) &&
  v >= -2147483648 &&
  v <= 2147483647 &&
  Number.isInteger(v);
function chkIdlU64(v: unknown): v is number {
  if (chkIdlU32(v)) {
    return true;
  }
  if (TypeChk.isNumber(v) && Number.isInteger(v) && v >= 0 && v < 2 << 54) {
    return true;
  }
  return true; // TODO: Check for a BigInt
}
function chkIdlI64(v: unknown): v is number {
  if (chkIdlI32(v)) {
    return true;
  }
  if (
    TypeChk.isNumber(v) &&
    Number.isInteger(v) &&
    v >= -(2 << 53) &&
    v < 2 << 53
  ) {
    return true;
  }
  return true; // TODO: Check for a BigInt
}
const chkIdlChar: TypeChk.typecheck<string> = (v: unknown): v is string =>
  TypeChk.isString(v) && v.length === 1;
function chkOptional<T>(chk: TypeChk.typecheck<T>): TypeChk.typecheck<T | undefined> {
  return (v: unknown): v is T | undefined => v === undefined || chk(v);
}
`);
}

async function footer(writer: Bun.FileSink): Promise<void> {
  await writer.write(`
// End of generated code
`);
}

function getTypeName(type: Types, optUndef?: boolean): string {
  if (
    isU8Type(type) ||
    isI8Type(type) ||
    isU16Type(type) ||
    isI16Type(type) ||
    isU32Type(type) ||
    isI32Type(type) ||
    isFloatType(type) ||
    isDoubleType(type)
  ) {
    return 'number';
  } else if (isU64Type(type) || isI64Type(type)) {
    return 'BigInt';
  } else if (isStringType(type) || isCharType(type)) {
    return 'string';
  } else if (isBoolType(type)) {
    return 'boolean';
  } else if (isRefType(type)) {
    return type.r; // Reference type, just return the name
  } else if (isArrayType(type)) {
    return `${getTypeName(type.d, true)}[]`;
  } else if (isSetType(type) || isFastSetType(type)) {
    return `Set<${getTypeName(type.d)}>`;
  } else if (isMapType(type) || isFastMapType(type)) {
    return `Map<${getTypeName(type.k)}, ${getTypeName(type.v)}>`;
  } else if (isTupleType(type)) {
    return `[${type.l.map((t) => getTypeName(t, true)).join(', ')}]`;
  } else if (isOptionalType(type)) {
    return optUndef
      ? `(${getTypeName(type.d)} | undefined)`
      : getTypeName(type.d);
  }
  throw new Error(`Unsupported unnamed type: ${JSON.stringify(type)}`);
}

function getTypeCheckName(type: Types): string {
  if (isU8Type(type)) {
    return 'chkIdlU8';
  } else if (isI8Type(type)) {
    return 'chkIdlI8';
  } else if (isU16Type(type)) {
    return 'chkIdlU16';
  } else if (isI16Type(type)) {
    return 'chkIdlI16';
  } else if (isU32Type(type)) {
    return 'chkIdlU32';
  } else if (isI32Type(type)) {
    return 'chkIdlI32';
  } else if (isU64Type(type)) {
    return 'chkIdlU64';
  } else if (isI64Type(type)) {
    return 'chkIdlI64';
  } else if (isFloatType(type)) {
    return 'chkIdlFloat';
  } else if (isDoubleType(type)) {
    return 'TypeChk.isNumber';
  } else if (isU64Type(type)) {
    return 'chkIdlU64';
  } else if (isI64Type(type)) {
    return 'chkIdlI64';
  } else if (isStringType(type)) {
    return 'TypeChk.isString';
  } else if (isCharType(type)) {
    return 'chkIdlChar';
  } else if (isBoolType(type)) {
    return 'TypeChk.isBoolean';
  } else if (isRefType(type)) {
    return `chk${type.r}`;
  } else if (isArrayType(type)) {
    return `TypeChk.chkArrayOf(${getTypeCheckName(type.d)})`;
  } else if (isSetType(type) || isFastSetType(type)) {
    return `TypeChk.chkSetOf(${getTypeName(type.d)})`;
  } else if (isMapType(type) || isFastMapType(type)) {
    return `TypeChk.chkMapOf(${getTypeCheckName(type.k)}, ${getTypeCheckName(type.v)})`;
  } else if (isTupleType(type)) {
    return `TypeChk.chkTuple(${type.l.map(getTypeCheckName).join(', ')})`;
  } else if (isOptionalType(type)) {
    return `chkOptional(${getTypeCheckName(type.d)})`;
  }
  throw new Error(
    `Unsupported unnamed type for checking: ${JSON.stringify(type)}\n(Probably use a reference)`,
  );
}
const enumType: EmitItem<Enum> = async (writer, name, item) => {
  await writer.write(`
export const ${name} = Object.freeze({
  ${item.v.map((val, idx) => `${val}: ${idx}`).join(',\n  ')}
});
export type ${name} = (typeof ${name})[keyof typeof ${name}];
export function chk${name}(val: unknown): val is ${name} {
  return TypeChk.isNumber(val) && Object.values(${name}).includes(val as ${name});
}
`);
};

const numEnumType: EmitItem<NEnum> = async (writer, name, item) => {
  await writer.write(`
export const ${name} = Object.freeze({
${Object.entries(item.v)
  .map(([key, value]) => `  ${key}: ${value},`)
  .join('\n')}
});
export type ${name} = (typeof ${name})[keyof typeof ${name}];
export function chk${name}(val: unknown): val is ${name} {
  return TypeChk.isNumber(val) && Object.values(${name}).includes(val as ${name});
}
`);
};

const strEnumType: EmitItem<SEnum> = async (writer, name, item) => {
  await writer.write(`
export const ${name} = Object.freeze({
${Object.entries(item.v)
  .map(([key, val]) => `  ${key}: '${SingleQuoteSafe(val)}',`)
  .join('\n')}
});
export type ${name} = (typeof ${name})[keyof typeof ${name}];
export function chk${name}(val: unknown): val is ${name} {
  return TypeChk.isString(val) && Object.values(${name}).includes(val as ${name});
}
`);
};

const objType: EmitItem<ObjType> = async (writer, name, item) => {
  const required = Object.entries(item.d)
    .filter(([_, v]) => !isOptionalType(v))
    .map(([k, _]) => k);
  const optional = Object.entries(item.d)
    .filter(([_, v]) => isOptionalType(v))
    .map(([k, _]) => k);
  if (required.length + optional.length !== Object.keys(item.d).length) {
    throw new Error(
      `Internal error: could not separate required/optional keys for ${name}`,
    );
  }
  await writer.write(`
export type ${name} = {`);
  for (const [key, value] of Object.entries(item.d)) {
    const typeName = getTypeName(value);
    await writer.write(
      `\n  ${key}${isOptionalType(value) ? '?' : ''}: ${typeName};`,
    );
  }
  await writer.write(`
}
export const chk${name}: TypeChk.typecheck<${name}> = TypeChk.chkObjectOfType({
${Object.entries(item.d)
  .map(([key, value]) => `  ${key}: ${getTypeCheckName(value)},`)
  .join('\n')}
    });
`);
};

const subType: EmitItem<SubType> = async (writer, name, item) => {
  await writer.write(`
export type ${name} = ${item.p} & {`);
  for (const [key, value] of Object.entries(item.d)) {
    const typeName = getTypeName(value);
    await writer.write(`\n  ${key}: ${typeName}; `);
  }
  await writer.write('\n};\n');
};

const simpleType: EmitItem<Types> = async (writer, name, item) => {
  await writer.write(`\nexport type ${name} = ${getTypeName(item, true)};\n`);
  if (isAnonymousType(item)) {
    await writer.write(`export const chk${name} = ${getTypeCheckName(item)}\n`);
  }
};

export const TypescriptEmitter: Emitter = {
  header,
  footer,
  types: {
    objType,
    subType,
    arrType: simpleType,
    setType: simpleType,
    fastSetType: simpleType,
    mapType: simpleType,
    fastMapType: simpleType,
    tupType: simpleType,
    enumType,
    strType: simpleType,
    numEnumType,
    strEnumType,
  },
};

export function GetTypescriptGenerator(): FileGenerator {
  // Returns the TypescriptEmitter instance
  return MakeGenerator(TypescriptEmitter);
}
