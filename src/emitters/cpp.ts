import {
  isArrayType,
  isBoolType,
  isCharType,
  isDoubleType,
  isFastMapType,
  isFastSetType,
  isFloatType,
  isI16Type,
  isI32Type,
  isI64Type,
  isI8Type,
  isMapType,
  isOptionalType,
  isPlainIntEnumType,
  isRefType,
  isSetType,
  isStringType,
  isTupleType,
  isU16Type,
  isU32Type,
  isU64Type,
  isU8Type,
} from '../IDL';
import type {
  Emitter,
  Enum,
  FileGenerator,
  IdlGenerator,
  NEnum,
  ObjType,
  OptType,
  SEnum,
  SubType,
  Types,
} from '../types';
import { MakeGenerator } from './api';

let guardName = '__CROW_IDL_GENERATED_HPP';
let sourceFileName = 'unknown.ts';
let namespace = 'Shared';

function setGuardName(name: string): void {
  guardName = name.toUpperCase().replace(/[^A-Z0-9]+/g, '_');
}

function setInputFilename(fileName: string): void {
  sourceFileName = fileName;
}

function setOutputFilename(fileName: string): void {
  setGuardName(fileName);
}

function setAdditionalOptions(opts: Record<string, string>): void {
  if (opts.namespace) {
    setNamespace(opts.namespace);
  }
  if (opts.guardName) {
    setGuardName(opts.guardName);
  }
}

function setNamespace(ns: string): void {
  namespace = ns;
}

function generateHeader(): string[] {
  return `// DO NOT EDIT THIS FILE DIRECTLY!!!
// This file is generated from ${sourceFileName} by running 'bun gen'
// If you need to change this file, edit ${sourceFileName} and run
// 'bun gen' again. Or, if you need to change the generation process, edit
// scripts/emitters/cpp.ts and run 'bun gen' again.
// DO NOT EDIT THIS FILE DIRECTLY!!!

// Generated by ${process.env.npm_package_name} v${process.env.npm_package_version}
#pragma once

#ifndef ${guardName}
#define ${guardName}

// TODO: Only include the necessary headers

#include <cstdint>
#include <map>
#include <optional>
#include <set>
#include <string>
#include <string_view>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include <crow/json.h>
 
// TODO: Inline this?
#include "json_pickling.hpp"

namespace ${namespace} {

template <typename T>
constexpr std::optional<T> from_string(const std::string_view& str);
`.split('\n');
}

const outsideNamespace: string[] = [];

function addNonNamespace(lines: string): void {
  outsideNamespace.push(lines);
}

function generateFooter(): string[] {
  const res = ['', '', `} // namespace ${namespace}`];
  res.push(...outsideNamespace);
  res.push('', `#endif // ${guardName}`, '');
  return res;
}

function getTypeName(type: Types, scoped?: boolean): string {
  if (isU8Type(type)) {
    return 'std::uint8_t';
  } else if (isI8Type(type)) {
    return 'std::int8_t';
  } else if (isU16Type(type)) {
    return 'std::uint16_t';
  } else if (isI16Type(type)) {
    return 'std::int16_t';
  } else if (isU32Type(type)) {
    return 'std::uint32_t';
  } else if (isI32Type(type)) {
    return 'std::int32_t';
  } else if (isU64Type(type)) {
    return 'std::uint64_t';
  } else if (isI64Type(type)) {
    return 'std::int64_t';
  } else if (isStringType(type)) {
    return 'std::string';
  } else if (isCharType(type)) {
    return 'char';
  } else if (isBoolType(type)) {
    return 'bool';
  } else if (isFloatType(type)) {
    return 'float';
  } else if (isDoubleType(type)) {
    return 'double';
  } else if (isRefType(type)) {
    return scoped ? `${namespace}::${type.r}` : type.r; // Reference type, just return the name
  } else if (isArrayType(type)) {
    return `std::vector<${getTypeName(type.d, !!scoped)}>`;
  } else if (isSetType(type)) {
    return `std::set<${getTypeName(type.d, !!scoped)}>`;
  } else if (isFastSetType(type)) {
    return `std::unordered_set<${getTypeName(type.d, !!scoped)}>`;
  } else if (isMapType(type)) {
    return `std::map<${getTypeName(type.k, !!scoped)}, ${getTypeName(type.v, !!scoped)}>`;
  } else if (isFastMapType(type)) {
    return `std::unordered_map<${getTypeName(type.k, !!scoped)}, ${getTypeName(type.v, !!scoped)}>`;
  } else if (isTupleType(type)) {
    return `std::tuple<${type.l.map((a) => getTypeName(a, !!scoped)).join(', ')}>`;
  } else if (isOptionalType(type)) {
    return `std::optional<${getTypeName(type.d, !!scoped)}>`;
  }
  throw new Error(`Unsupported unnamed type: ${JSON.stringify(type)}`);
}

function enumType(name: string, item: Enum): string[] {
  const typeName = isPlainIntEnumType(item.u)
    ? ''
    : ` : ${getTypeName(item.u)}`;
  return [
    `
#pragma region numeric enum ${name}
enum class ${name}${typeName} {
  ${item.v.join(',\n  ')}
};

inline constexpr bool is_valid(${name} _value) {
  switch (_value) {
${item.v.map((val) => `    case ${name}::${val}:`).join('\n')}
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(${name} _value) {
  switch (_value) {
${item.v
  .map(
    (val) => `    case ${name}::${val}:
      return "${val}";`,
  )
  .join('\n')}
    default:
      return "<unknown>";
  }
}
#pragma endregion numeric enum ${name}
    ]
`,
  ];
}

function numEnumType(name: string, item: NEnum): string[] {
  const typeName = isPlainIntEnumType(item.u)
    ? ''
    : ` : ${getTypeName(item.u)}`;
  return `
#pragma region linear enum ${name}
enum class ${name}${typeName} {
${Object.entries(item.v)
  .map(([key, value]) => `  ${key} = ${value},`)
  .join('\n')}
};

inline constexpr bool is_valid(${name} _value) {
  switch (_value) {
${Object.entries(item.v)
  .map(([key]) => `    case ${name}::${key}:`)
  .join('\n')}
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(${name} _value) {
  switch (_value) {
${Object.entries(item.v)
  .map(
    ([key, _]) => `    case ${name}::${key}:
      return "${key}";`,
  )
  .join('\n')}
    default:
      return "<unknown>";
  }
}

#pragma endregion linear enum ${name}
`.split('\n');
}

function strEnumType(name: string, item: SEnum): string[] {
  const res = `
#pragma region string enum ${name}

enum class ${name} {
  ${Object.keys(item.v)
    .map((key) => `${key}`)
    .join(',\n  ')}
};

inline constexpr bool is_valid(${name} _value) {
  switch (_value) {
${Object.entries(item.v)
  .map(([key]) => `    case ${name}::${key}:`)
  .join('\n')}
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(${name} _value) {
  switch (_value) {
${Object.entries(item.v)
  .map(
    ([key, val]) => `    case ${name}::${key}:
      return "${val}";`,
  )
  .join('\n')}
    default:
      return "<unknown>";
  }
}

// This is *super* simplistic, and should be optimized, cuz this is bad.
// A deeply nested switch statement would be pretty fun to generate...
template <>
inline constexpr std::optional<${name}>
from_string<${name}>(const std::string_view& str) {
${Object.entries(item.v)
  .map(
    ([key, val]) => `  if (str == "${val}")
    return ${name}::${key};`,
  )
  .join('\n')}
  return std::nullopt;
}

#pragma endregion string enum ${name}
`.split('\n');

  addNonNamespace(`#pragma region JSON serialization for string enum ${name}
template <>
inline crow::json::wvalue to_json<${namespace}::${name}>(
    ${namespace}::${name} _value) {
  return to_json(to_string(_value));
} 
template <>
struct impl_from_json<${namespace}::${name}> {
  static inline std::optional<${namespace}::${name}> process(
      const crow::json::rvalue& _value) {
    if (_value.t() != crow::json::type::String)
      return std::nullopt;
    auto _str = _value.s();
    return ${namespace}::from_string<${namespace}::${name}>(
        std::string_view{_str.begin(), _str.size()});
  }
};
#pragma endregion JSON serialization for string enum ${name}
`);
  return res;
}

function objType(name: string, item: ObjType): string[] {
  const res = ['', `struct ${name} {`, ''];
  for (const [key, value] of Object.entries(item.d)) {
    const typeName = getTypeName(value);
    res.push(`  ${typeName} ${key};`);
  }
  res.push('};');
  const required = Object.entries(item.d).filter(
    ([_, v]) => !isOptionalType(v),
  );
  const optional = Object.entries(item.d).filter(([_, v]) => isOptionalType(v));
  addNonNamespace(`
#pragma region JSON serialization for object ${name}
template <> 
struct impl_to_json<${namespace}::${name}> { 
  static inline crow::json::wvalue process(
      const ${namespace}::${name}& _value) {
    crow::json::wvalue _res;
    ${required
      .map(([key, _]) => `_res["${key}"] = to_json(_value.${key});`)
      .join('\n    ')}
    ${optional
      .map(
        ([key, _]) => `if (_value.${key}) {
       _res["${key}"] = to_json(*_value.${key});
      }`,
      )
      .join('\n    ')}
    return _res;
  }
};

template <>
inline std::optional<${namespace}::${name}>
from_json<${namespace}::${name}>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  ${namespace}::${name} _res;
  ${required
    .map(
      ([key, value]) => `
  if (!_value.has("${key}"))
    return std::nullopt;
  auto _${key}_opt_ = from_json<${getTypeName(value, true)}>(_value["${key}"]);
  if (!_${key}_opt_.has_value())
    return std::nullopt;
  _res.${key} = std::move(*_${key}_opt_);`,
    )
    .join('\n  ')}
  ${optional
    .map(
      ([key, value]) => `
  if (_value.has("${key}")) {
    auto _${key}_opt_ = from_json<${getTypeName((value as OptType).d, true)}>(_value["${key}"]);
    if (!_${key}_opt_.has_value())
      return std::nullopt;
    _res.${key} = std::move(*_${key}_opt_);
  } else {
    _res.${key} = std::nullopt;
  }`,
    )
    .join('\n  ')}
  return _res;
}
#pragma endregion JSON serialization for object ${name}
`);
  return res;
}

function subType(name: string, item: SubType): string[] {
  const res = ['', `struct ${name} : ${item.p} {`, ''];
  for (const [key, value] of Object.entries(item.d)) {
    const typeName = getTypeName(value);
    res.push(`  ${typeName} ${key};`);
  }
  res.push('};');

  addNonNamespace(`
#pragma region JSON serialization for object ${name}
template <> 
struct impl_to_json<${namespace}::${name}> { 
  static inline crow::json::wvalue process(
      const ${namespace}::${name}& _value) {
    crow::json::wvalue _res = impl_to_json<${namespace}::${item.p}>::process(_value);
    ${Object.entries(item.d)
      .map(([key]) => `_res["${key}"] = to_json(_value.${key});`)
      .join('\n    ')}
    return _res;
  }
};

template <>
inline std::optional<${namespace}::${name}>
from_json<${namespace}::${name}>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  std::optional<${namespace}::${item.p}> _base = from_json<${namespace}::${item.p}>(_value);
  if (!_base.has_value())
    return std::nullopt;
  
  ${Object.entries(item.d)
    .map(
      ([key, value]) => `
  if (!_value.has("${key}"))
    return std::nullopt;
  auto _${key}_opt_ = from_json<${getTypeName(value, true)}>(_value["${key}"]);
  if (!_${key}_opt_.has_value())
    return std::nullopt;
  `,
    )
    .join('\n  ')}
  ${namespace}::${name} _res{std::move(*_base), ${
    // std::move the fields of the base, plus the inherited fields
    Object.entries(item.d)
      .map(([key, value]) => `std::move(*_${key}_opt_)`)
      .join(', ')
  }};

  return _res;
}
#pragma endregion JSON serialization for object ${name}
`);
  return res;
}
function usingType(name: string, item: Types): string[] {
  // This is a base/simple type, so we don't need to do anything special,
  // just a simple using statement:
  return [`using ${name} = ${getTypeName(item)};`];
}

export const CppEmitter: Emitter = {
  setInputFilename,
  setOutputFilename,
  setAdditionalOptions,
  generateHeader,
  generateFooter,
  types: {
    objType,
    subType,
    enumType,
    numEnumType,
    strEnumType,
    optType: usingType,
    arrType: usingType,
    setType: usingType,
    fastSetType: usingType,
    mapType: usingType,
    fastMapType: usingType,
    tupType: usingType,
    strType: usingType,
  },
};

export function GetCppGenerator(): IdlGenerator {
  // Returns the CppEmitter instance
  return MakeGenerator(CppEmitter);
}
